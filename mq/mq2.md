##　源码咋看
1. 官方文档
2. 经典论文
3. 代码示例
4. 带着问题剖析代码细节

## 异步 -> 性能优化

异步编程模型，虽然不能加快程序本身的速度，但可以减少或避免线程等待，只用少量的线程就可以达到超高的吞吐能力

## 高性能异步网络框架
IO操作： 网络IO和磁盘IO

发送数据： 写入的数据先暂存在缓存中，然后会通过网卡传输到对端的服务器上。
因此写入时，如果缓存没满，就是写入缓存的时间，没有必要异步。

接收数据： 

同步网络IO模型： 接收线程阻塞等待数据，有数据时写入接收缓存，然后给接收线程发一个通知，线程收到通知之后结束等待，开始读取数据。

问题： 大量连接时，会有大量的线程抢占CPU时间，造成频繁的CPU上下文切换，导致CPU负载升高

异步网络IO：使用Netty实现异步网络通信

## 序列化与反序列化
消息队列等中间件通常使用专用的序列化方法
## 传输协议
数据分割：
- 分隔符
- 先长度后内容（前置长度）
用双工收发协议提升吞吐量
- 使用ID来标识请求与响应对应关系

## 高并发下的内存管理技巧
1. 尽量少地创建一次性对象，特别是大对象
2. 对于需要频繁使用，但又是一次性的大对象，考虑自行回收并重用。
    - 对象池。收到请求后，在对象池申请一个对象，使用完再放回去，反复重用这些对象
3. 自己进行内存管理

## JMQ

## Kafka高性能设计
- 使用批量处理的方式提升系统吞吐能力
- 基于磁盘文件高性能顺序读写的特性来涉及到存储结构（WAL）
- 利用操作系统的PageCache来缓存数据，减少IO并提升读性能
- 使用零拷贝技术加速消费流程

## 合理使用缓存策略减少磁盘IO

- 读写缓存
- 只读缓存
    - 如何更新
        - 更新数据的同时更新缓存
        - 定期更新全部换成
        - 给缓存中的每个数据设置一个有效期，让它自然过期来达到更新目的
- 缓存置换策略 
    - LRU(Least Recently Use)
    - LRU 2Q
        - 简化版本的2Q，比通常使用的LRU多了一个FIFO队列，数据先进FIFO队列，只有在第二次访问时才放到LRU队列里。
        - 完整版本的2Q，比简化版本的2Q又多了一个FIFO队列
    - ARC: LRU和LFU结合，再加上ghost list用于自适应调整LRU和LFU的长度。LRU -> LFU 
    - 定制化置换策略


## 锁


## 硬件同步原语替代锁

常见的硬件同步原语（Atomic Hardware Primitives）：CAS和FAA

## 数据压缩
压缩时间和压缩率
压缩分段的大小
