
今天我分享的主题是Spring Security与密码存储

我们先来看一下Spring Security 的特性，其中一项就是密码存储。这也是我这次分享的主要内容。

说起密码存储，我们可能不止一次看到这样的新闻。2011年CSDN网站明文存储的密码泄露，2019年，Facebook明文存储6亿用户的密码。
这样的事件屡见不鲜。

首先来了解一下密码存储机制的发展史。

多年来，存储密码的标准机制不断发展。起初，密码以纯文本形式存储。因为存储密码的数据被保存需要凭据才能访问的地方。但是，恶意用户能够使用 SQL 注入等攻击获取大量用户名和密码。随着越来越多的用户凭证公开，安全专家意识到我们需要做更多的工作来保护用户的密码。

然后鼓励开发人员使用单向哈希（例如 SHA-256）对密码哈希后进行存储。当用户尝试进行身份验证时，存储的哈希密码将与他们键入的密码的哈希值进行比较。这意味着系统只需要存储密码的单向哈希。如果发生违规，也只是公开密码的单向哈希。由于是单向哈希，并且在给定哈希值的情况下在计算上破译密码很困难，因此破译系统中的每个密码需要耗费的代价并不值得。
但恶意用户可以通过Rainbow Tables来破译密码。他们不是每次都通过计算来猜测密码，而是计算一次密码并将其存储在查找表中。也就是以空间换时间。
彩虹表的原理基于时空折中。
常规的破解方法有字典破解和暴力穷举。
字典破解就是存储常用的用户名密码和其对应的hash值，破解时进行匹配查找就可以，但是这种破解方式很依赖于字典的构造，用户名密码组合方式很多，也意味着其需要大量存储空间。
暴力破解则是依次计算1-N位字符串的密码值与需破解的密码进行比较，需要依赖强大的计算能力。
而彩虹表就是将其折中。通过相对于原始字典破解而言较小的存储空间，来破解密码。

构造彩虹表常常需要设计Reduce（规约）函数，它和Hash函数相反。具体点来说，就是两者的定义域和值域是相反的
比如说，如果说Hash函数的定义是 y = H(x), y属于（0~9,a-z,A-Z）,x属于（a-z）
那么，Reduce函数的定义就应该与之相反， y' = R(x'), y'属于（a-z）,x' 属于（0~9,a-z,A-Z）

但是很显然，因为哈希是单向不可逆的，我们没有办法通过一次Reduce函数完全地还原出原文是什么。
但是经过几次的H函数和R函数的迭代，最终我们得到了一个链表。这个链表里就包含了很多明文和其hash值的关系。
如果说，彩虹表也是把整个链表都保存下来，那它和字典破解也就没有太大不同了。
彩虹表的不同之处在于只取其首尾结点，因为中间结点都是可以通过H函数和R函数迭代计算出来的。
比如说 我们要破译rscdf这个密文，先进行一次R函数计算，
然后会从遍历彩虹表的所有尾结点看能不能找到，如果没有找到，再进行一次H函数和R函数，再去尾结点查找。

为了降低 Rainbow Tables 的有效性，鼓励开发人员使用加盐密码。不仅将密码用作哈希函数的输入，还将为每个用户的密码生成随机salt。盐和用户的密码将通过哈希函数运行，产生唯一的哈希值。盐将以明文形式与用户密码一起存储。然后，当用户尝试进行身份验证时，散列密码将与存储的盐和他们键入的密码的散列进行比较。随机盐意味着彩虹表不再有效，因为每个盐和密码组合的哈希值都不同。

但是随着硬件的发展，我们意识到加密哈希（如 SHA-256）不再安全。原因是使用现代硬件，我们可以每秒执行数十亿次哈希计算。这意味着我们可以轻松地单独破解每个密码。

现在鼓励开发人员利用自适应单向函数来存储密码。使用自适应单向函数验证密码是有意占用资源（即 CPU、内存等）的。自适应单向功能允许配置“工作系数”，该系数可以随着硬件的发展而增长。建议将“工作系数”调整为大约需要 1 秒来验证系统上的密码。这种权衡是为了让攻击者难以破解密码，但成本不会高到给您自己的系统带来过大的负担。

Spring Security中支持了几种自适应单向加盐哈希算法，如bcrypt、PBKDF2、scrypt 和 argon2。其对应的实现分别如右。

这几个实现都是实现了PasswordEncoder这个接口。我们简单看一下这个接口的内容。
主要有encode函数，对用户密码进行编码加密；
matches函数，则是匹配验证用户键入的密码与数据库中存储的密文是否一致
Spring Security中默认的加密方法是Bcrypt算法。
我们先演示一个代码，看一下BCrypt算法生成的密文结构。

了解密文结构，我们再回去看一下刚才的代码演示结果，可以看到循环次数对加密时间的影响。

如何进行匹配的？
简单来看一下源码的匹配过程，是拿到用户键入密码，和密文。
从密文中抽取出来算法版本、循环的次数还有salt。对用户键入密码按照这些信息进行加密得到结果，并和密文进行匹配。

循环次数，也就是work factor，就是1999年，这两个人发表的论文中提出的。

BCrypt 实现了 OpenBSD风格的 Blowfish 加密哈希算法。 A Future-Adaptable Password Scheme 论文中描述的模式
该加密Hash系统尝试使用基于 Bruce Schneier 的 Blowfish 密码的计算密集型hash算法来阻止离线密码破解。
该算法的工作因子是参数化的，因此可以随着计算机速度的提高而增加。

crypt_raw 核心密码哈希步骤，其中最耗时的地方是 for(i = 0; i < rounds; i++),这里计算了2^strength次

encode_base64: 使用bctypt稍作修改的base64编码模式对字节数组编码。该编码模式和标准MIMEbase64编码不兼容。

bcrypt (cost, salt, pwd )
    state EksBlowfishSetup (cost, salt, key)
    ctext "OrpheanBeholderScryDoubt"
    repeat (64)
        ctext EncryptECB (state, ctext)
    return Concatenate (cost, salt, ctext)

这个算法主要有几个步骤:
首先就是使用Expensive key setup算法初始化Blowfish状态，其实也就是P盒和S盒
然后利用P和S对这个文本重复加密64次

EksBlowfishSetup (cost, salt, key)
    // 用圆周率pi的数字填充到子密钥，和S-boxes
 state ← InitState ()
    // 根据salt和key 置换P和S-boxes
 state ← ExpandKey (state, salt, key)
 repeat (2cost )
        // 与上面类似
  state ← ExpandKey (state, 0, salt)
  state ← ExpandKey (state, 0, key)
 return state

ExpandKey的过程
根据128位的salt和可变长度的密钥修改 P 和 S

1. P中子密钥与加密密钥异或
2. 密钥的前32位和P1异或，接下来的32位于P2异或，依次类推。
3. 直到密钥的末尾，开始重用从头开始的位与子密钥异或
随后，ExpandKey使用P的当前状态对salt参数的前64位进行加密。生成的密文替换子密钥P1和P2.同样的密文再与salt的后64位进行异或。其结果用P的新状态加密。
第二次加密的输出替换P3和P4.它再和salt的前64位异或并加密替换P5和P6。
该过程继续，在盐的前64位和后64位直接交替。
当ExpandKey完成替换P数组，它会继续依次替换两个S元素，更换后，最后一个S-box的最后两个条目，S4[254]和S4[255],ExpandKey返回新的key schedule.

1. P和S的不可预测及变化的内容会降低未来优化的适用性
2. S-Box需要4kb的不断访问和修改内存。因此，S-box 不能被共享使用，每次同时执行时必须存在单独的S-box。这极大地限制了在硬件中管道 Feistel 网络的任何尝试的有用性。

Blowfish是一个64位的分组密码算法。
它使用18个32位的由密钥中衍生得到的子密钥，P1-P18。这些子密钥叫做P数组。

Blowfish把64位输入块分成两个32位L0和RO来加密。

1 <= i <= 16
Ri = Li-1 ^ Pi,
Li = Ri-1 ^ F(Ri).

经过16轮之后，这两半再次被交换，并且每一个班和另一半的32位子密钥异或
R17 = L16 ^ P17,
L17 = R16 ^ P18.

F函数使用了4个从加密密钥中衍生出来的数组，S1,...,S4。
每个数组包含256个32位。
数组充当替代盒或S盒，用32位输出替换8位输入。F函数将其32位输入拆分为4个8位的字节，a,b,c,d。并为每个字节替换一个S盒的内容，并将结果组合
F (a; b; c; d) = (S1[a]  S2[b])  S3[c]  S4[d]

Eksblowfish和Blowfish的区别：加密密钥衍生得到子密钥和S-boxes
