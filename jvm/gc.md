# 垃圾收集

## 常见的垃圾收集算法

### 引用计数

### 标记整理

### 标记清除

* 第一步是遍历对象，看哪些是存活的
* 第二部把不是存活的对象清除

缺点： 空间碎片严重

### 标记复制

## 分代垃圾收集

为什么会分代垃圾收集？基于几个假说

* 弱分代假说：也就是说大多数对象都是朝生夕灭的
* 强分代假说：熬过越多次垃圾收集的对象越难以消灭
* 跨代引用假说：跨代引用相对于同代引用来说极少

基础理论

* 根节点枚举
* 安全点
* 安全区域
* 记忆集与卡表
* 写屏障
* 并发的可达性分析： 增量更新和原始快照

## JVM中的垃圾收集器

### Serial

单线程的新生代垃圾收集器，采用标记复制

### ParNew

多线程的新生代垃圾收集器，与Serial唯一不同就是多线程

### Parallel Scavenge

以吞吐量为目标的新生代垃圾收集器

标记复制

### CMS

以最小停顿时间为目标的老年代收集器

使用标记清除，如果没有空间分配，会降级为Serial Old进行标记整理

### Serial Old

标记整理

### Parellel Old

和Parallel Scavenge搭配使用

标记整理

### G1

以Region为最小收集单位，每个Region有自己的角色，Eden、Survivor、Old，收集时根据角色采用不同的垃圾收集算法。

记忆集记录别的Region到当前Region有没有引用，卡表

并发标记时，使用了原始快照的方式来处理

可预测停顿模型，其原理是每个Region都维护了一些收集数据，整体有一个优先级列表，按照期望时间来选择一些Region来进行回收

### Shenandoah

### ZGC

